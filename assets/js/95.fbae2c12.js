(window.webpackJsonp=window.webpackJsonp||[]).push([[95],{446:function(t,s,a){"use strict";a.r(s);var n=a(25),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"前段模块化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前段模块化"}},[t._v("#")]),t._v(" 前段模块化")]),t._v(" "),a("p",[t._v("在搞懂它们之前的区别,首先得理解 前段模块化. 模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。")]),t._v(" "),a("h1",{attrs:{id:"commonjs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#commonjs"}},[t._v("#")]),t._v(" CommonJS")]),t._v(" "),a("p",[t._v("Node.js是commonJS规范的主要实践者，它有四个重要的环境变量为模块化的实现提供支持："),a("strong",[t._v("module")]),t._v(","),a("strong",[t._v("exports")]),t._v(","),a("strong",[t._v("require")]),t._v(","),a("strong",[t._v("global")]),t._v(". 实际使用时,用 "),a("strong",[t._v("module.exports")]),t._v("定义当前模块对外输出的接口（不推荐直接用exports）, 用 "),a("strong",[t._v("require")]),t._v(" 加载模块。")]),t._v(" "),a("p",[a("strong",[t._v("CommonJS的特点")])]),t._v(" "),a("ul",[a("li",[t._v("所有代码都运行在模块作用域，不会污染全局作用域")]),t._v(" "),a("li",[t._v("模块是同步加载的，即只有加载完成，才能执行后面的操作")]),t._v(" "),a("li",[t._v("模块在首次执行后就会缓存，再次加载只返回缓存结果，如果想要再次执行，可清除缓存")]),t._v(" "),a("li",[t._v("CommonJS输出是值的拷贝(即，require返回的值是被输出的值的拷贝，模块内部的变化也不会影响这个值)。")])]),t._v(" "),a("p",[a("strong",[t._v("ES6模块与 COmmonJS 模块的差异")])]),t._v(" "),a("p",[t._v("它们有两个重大差异。")]),t._v(" "),a("ul",[a("li",[t._v("CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用")]),t._v(" "),a("li",[t._v("CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。")])]),t._v(" "),a("p",[t._v("第二个差异是因为 CommonJS 加载的是一个对象(即module.exports属性),该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 定义模块math.js")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" basicNum "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("a"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" b")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" a "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\nmodule"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("exports "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//在这里写上需要向外暴露的函数、变量")]),t._v("\n  add"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" add"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("\n  basicNum"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" basicNum\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 引用自定义的模块时，参数包含路径，可省略.js")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" math "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("require")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'./math'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\nmath"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("h1",{attrs:{id:"amd-和-require-js"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#amd-和-require-js"}},[t._v("#")]),t._v(" AMD 和 require.js")]),t._v(" "),a("p",[a("strong",[t._v("AMD")]),t._v(" 规范采用异步方式加载模块,模块的加载不影响它后面语句的运行。所有依赖这个模块的语句，都定义在一个回调函数中，等到加载完成之后，这个回调函数才会运行。")]),t._v(" "),a("p",[a("strong",[t._v("require.js")]),t._v(" 实现 AMD 规范的模块化：用 **define()**定义模块，用 **require()**加载模块。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("//a.js\n//define可以传入三个参数，分别是字符串-模块名、数组-依赖模块、函数-回调函数\ndefine(function(){\n    return 1;\n})\n\n// b.js\n//数组中声明需要加载的模块，可以是模块名、js文件路径\nrequire(['a'], function(a){\n    console.log(a);// 1\n});\n")])])]),a("p",[a("strong",[t._v("RequireJS的特点")]),t._v("\n对于依赖的模块,AMD推崇依赖前置,提前执行. 也就是说,在 "),a("strong",[t._v("define")]),t._v(" 方法里传入的依赖模块(数组),会在一开始就下载并执行。")]),t._v(" "),a("h1",{attrs:{id:"cmd"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cmd"}},[t._v("#")]),t._v(" CMD")]),t._v(" "),a("p",[t._v("CMD是SeaJS在推广过程中生产的对模块定义的规范,在Web浏览器端的模块加载器中,SeaJS与RequireJS并称,SeaJS作者为阿里的玉伯。")]),t._v(" "),a("p",[a("strong",[t._v("使用 exports 暴露模块接口")])]),t._v(" "),a("p",[t._v("使用 sea.js 创建一个模块，文件名为：hangge.js")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("define(function(require, exports) {\n    // 对外提供name属性\n    exports.name = 'hangge';\n    // 对外提供hello方法\n    exports.hello = function() {\n      console.log('Hello hangge.com');\n    };\n});\n")])])]),a("p",[t._v("在 HTML 页面使用")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('<script type="text/javascript" src="sea.js"><\/script>\n    <script type="text/javascript">\n        //加载一个模块，在加载完成时，执行回调\n        seajs.use(\'hangge\', function(a) {\n        a.hello();\n    });\n<\/script>\n')])])]),a("p",[a("strong",[t._v("SeaJS的特点")])]),t._v(" "),a("p",[t._v("对于依赖的模块, "),a("strong",[t._v("CMD")]),t._v(" 推崇依赖就近,延迟执行。也就是说,只有到require时依赖模块才执行。")]),t._v(" "),a("h1",{attrs:{id:"es6-module"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#es6-module"}},[t._v("#")]),t._v(" ES6 Module")]),t._v(" "),a("p",[t._v("其模块功能主要由两个命令构成："),a("strong",[t._v("export")]),t._v(" 和 "),a("strong",[t._v("import")]),t._v("。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("/** export default **/\n//定义输出\nexport default { basicNum, add };\n//引入\nimport math from './math';\nfunction test(ele) {\n    ele.textContent = math.add(99 + math.basicNum);\n}\n\n")])])]),a("p",[t._v("ES6的模块不是对象，import命令会被 JavaScript 引擎静态分析，在编译时就引入模块代码，而不是在代码运行时加载，所以无法实现条件加载。也正因为这个，使得静态分析成为可能。")])])}),[],!1,null,null,null);s.default=e.exports}}]);