(window.webpackJsonp=window.webpackJsonp||[]).push([[128],{478:function(r,e,t){"use strict";t.r(e);var v=t(25),_=Object(v.a)({},(function(){var r=this,e=r.$createElement,t=r._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[t("h1",{attrs:{id:"react-fiber"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-fiber"}},[r._v("#")]),r._v(" React-Fiber")]),r._v(" "),t("h2",{attrs:{id:"fiber-是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fiber-是什么"}},[r._v("#")]),r._v(" Fiber 是什么")]),r._v(" "),t("p",[t("strong",[r._v("JavaScript")]),r._v(" 是单线程的,这意味着我们只有一个线程可以执行所有UI更新,处理用户操作和网络调用等。")]),r._v(" "),t("p",[r._v("在 Fiber 之前 React 有两棵树🌲,一棵是当前树,另一棵是带有所有新更新的更新树🌲。 协调器将在一次通过中同步找到两个树🌲之间的差异,这个过程不能被打断,得全部执行完一把梭更新, 节点过多会导致卡顿,这将阻止主线程执行其他重要任务,例如某些用户操作")]),r._v(" "),t("p",[r._v("因此,Facebook团队在React 16更新中引入了Fiber作为其核心架构。")]),r._v(" "),t("p",[t("strong",[r._v("Fiber")]),r._v(" 就是一个数据结构,它有很多属性,虚拟 dom 就是对真实 dom 的一种简化 一些真实 dom 做不到的对象  虚拟 dom 更做不到。 因此有了 fiber、希望借由 fiber 上的这堆属性 来做一些比较厉害的事件")]),r._v(" "),t("h2",{attrs:{id:"fiber-架构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#fiber-架构"}},[r._v("#")]),r._v(" Fiber 架构")]),r._v(" "),t("p",[r._v("为了弥补上面的不足、设计了一些新的算法、为了让这些算法跑起来、所以出现了 "),t("strong",[r._v("Fiber")]),r._v(" 数据结构")]),r._v(" "),t("p",[t("strong",[r._v("Fiber")]),r._v(" 数据结构 + 算法 = "),t("strong",[r._v("Fiber")]),r._v(" 架构")]),r._v(" "),t("p",[t("strong",[r._v("React")]),r._v(" 应用从始至终 管理着最基本的三样东西")]),r._v(" "),t("ol",[t("li",[t("p",[r._v("Root(整个应用的根 一个对象 不是 Fiber 同时有个属性指向 workInProgress)")])]),r._v(" "),t("li",[t("p",[r._v("current 树(树上的每一个节点都是 Fiber 保存的是上一次的状态 并且每个FIber节点 都对应这一个 jsx 节点)")])]),r._v(" "),t("li",[t("p",[t("strong",[r._v("workInProgress")]),r._v(" 树(树上的每一个节点Fiber 保存的是本次新的节点 并且每个Fiber 节点都对应一个 jsx 节点)")])])]),r._v(" "),t("h2",{attrs:{id:"如何工作"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何工作"}},[r._v("#")]),r._v(" 如何工作")]),r._v(" "),t("p",[r._v("没有 current 树,React 在一开始创建 Root 就会创建一个 uninitiaFiber (未初始化的FIber)\n让 react 的 current 指向 uninitiaFiber,之后再去创建一个本次要用到的 workInProgress")]),r._v(" "),t("ul",[t("li",[r._v("ReactDOM.render() 和 setState 的时候开始创建更新。")]),r._v(" "),t("li",[r._v("将创建的更新加入任务队列，等待调度。")]),r._v(" "),t("li",[r._v("在 requestIdleCallback 空闲时执行任务。")]),r._v(" "),t("li",[r._v("从根节点开始遍历 Fiber Node，并且构建 WokeInProgress Tree。")]),r._v(" "),t("li",[r._v("生成 effectList。")]),r._v(" "),t("li",[r._v("根据 EffectList 更新 DOM。")])]),r._v(" "),t("p",[r._v("WorkInProgress Tree 构造完毕，得到的就是新的 Fiber Tree,然后喜新厌旧（把 current 指针指向 WorkInProgress Tree，丢掉旧的 Fiber Tree）就好了。")]),r._v(" "),t("p",[r._v("这样做的好处：")]),r._v(" "),t("ul",[t("li",[t("p",[r._v("能够复用内部对象（fiber）")])]),r._v(" "),t("li",[t("p",[r._v("节省内存分配、GC的时间开销")])])]),r._v(" "),t("p",[r._v("就算运行中有错误，也不会影响 View 上的数据")]),r._v(" "),t("p",[r._v("每个 Fiber上都有个 "),t("strong",[r._v("alternate")]),r._v("属性,也指向一个 Fiber,创建 WorkInProgress 节点时优先取 "),t("strong",[r._v("alternate")]),r._v(",没有的话就创建一个。")]),r._v(" "),t("p",[r._v("创建 WorkInProgress Tree 的过程也是一个 Diff 的过程，Diff 完成之后会生成一个 "),t("strong",[r._v("Effect List")]),r._v(",这个 "),t("strong",[r._v("Effect List")]),r._v(" 就是最终 Commit 阶段用来处理副作用的阶段。")]),r._v(" "),t("h2",{attrs:{id:"react-主要分两个阶段"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#react-主要分两个阶段"}},[r._v("#")]),r._v(" React 主要分两个阶段")]),r._v(" "),t("p",[t("img",{attrs:{src:"/react/lifecycle.png",alt:"react-fiber"}})]),r._v(" "),t("ol",[t("li",[r._v("render 阶段 指的是创建 fiber 过程")])]),r._v(" "),t("ul",[t("li",[r._v("为每个节点创建新的 fiber(workInProgress) 可能是复用 生成一棵有新状态的 workInProgress 树")]),r._v(" "),t("li",[r._v("初次渲染的时候(或新创建了某个节点) 会将这个 fiber 创建真实的dom 实例,并且对当前节点的子节点进行插入 appendchild")]),r._v(" "),t("li",[r._v("如果不是初次渲染的话 就对比新旧的 fiber 状态 将产生了更新的fiber节点 最终通过链表的形式挂在到 RootFiber")])]),r._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[r._v("commit 阶段 才是真正要操作页面的阶段")])]),r._v(" "),t("ul",[t("li",[r._v("执行生命周期")]),r._v(" "),t("li",[r._v("会从 RootFiber 上获取到那条链表 根据链表上的标识 来操作页面")])]),r._v(" "),t("p",[r._v("在渲染阶段调用的生命周期方法：")]),r._v(" "),t("ul",[t("li",[t("strong",[r._v("getDerivedStateFromProps")])]),r._v(" "),t("li",[t("strong",[r._v("shouldComponentUpdate")])]),r._v(" "),t("li",[t("strong",[r._v("render")])])]),r._v(" "),t("p",[r._v("不管是初次渲染还是更新 都是从根往下遍历的")]),r._v(" "),t("p",[r._v("在提交阶段调用的生命周期方法：")]),r._v(" "),t("ul",[t("li",[t("strong",[r._v("getSnapshotBeforeUpdate")])]),r._v(" "),t("li",[t("strong",[r._v("componentDidMount")])]),r._v(" "),t("li",[t("strong",[r._v("componentDidUpdate")])]),r._v(" "),t("li",[t("strong",[r._v("componentWillUnmount")])])]),r._v(" "),t("p",[r._v("由于这些方法在提交阶段被调用，因此它们可能包含任何副作用和DOM操作操作")]),r._v(" "),t("blockquote",[t("p",[r._v("这里要特别注意的是，阶段1（渲染）可以暂停和恢复，即，它是异步的，而阶段2必须在一个流程中完成（同步）。")])]),r._v(" "),t("h2",{attrs:{id:"prioritization"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#prioritization"}},[r._v("#")]),r._v(" Prioritization")]),r._v(" "),t("p",[r._v("React系统如何确定要暂停/恢复哪个进程?")]),r._v(" "),t("p",[t("strong",[r._v("优先级")]),r._v(" 是React Fiber最重要的功能之一。\nFiber Reconciler为任务分配优先级，并根据优先级将更新这些更改")]),r._v(" "),t("p",[r._v("根据任务，React分配以下优先级:")]),r._v(" "),t("ul",[t("li",[r._v("同步")]),r._v(" "),t("li",[r._v("高优先级")]),r._v(" "),t("li",[r._v("低优先级")]),r._v(" "),t("li",[r._v("场外工作(优先)等")])]),r._v(" "),t("p",[r._v("例如,在所有组件的优先级中，将textInput类型事件指定为高优先级。")]),r._v(" "),t("p",[r._v("按照优先级执行,如果插入了新的任务,那么也按照优先级重新排序,分别是 "),t("strong",[r._v("window.requestAnimationFrame")]),r._v(" 和 "),t("strong",[r._v("window.requestIdleCallback")])])])}),[],!1,null,null,null);e.default=_.exports}}]);