(window.webpackJsonp=window.webpackJsonp||[]).push([[73],{422:function(t,e,a){"use strict";a.r(e);var s=a(25),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"传输加载优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#传输加载优化"}},[t._v("#")]),t._v(" 传输加载优化")]),t._v(" "),a("h2",{attrs:{id:"启动压缩-gzip"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#启动压缩-gzip"}},[t._v("#")]),t._v(" 启动压缩 Gzip")]),t._v(" "),a("p",[t._v("在 修改 Nginx 配置,启动"),a("strong",[t._v("Gzip")]),t._v("压缩")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("gzip                on;\n")])])]),a("h2",{attrs:{id:"keep-alive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#keep-alive"}},[t._v("#")]),t._v(" Keep-Alive")]),t._v(" "),a("p",[a("strong",[t._v("Keep-Alive")]),t._v(" 在 Http1.1 默认是开启的,可以在 Response Header 中可以看到 "),a("strong",[t._v("Connection: keep-alive")])]),t._v(" "),a("p",[t._v("在 nginx 配置中有两个比较重要的配置")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[t._v("keepalive_timeout "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("65")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 保持连接的时间，也叫超时时间，单位秒")]),t._v("\nkeepalive_request "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 最大连接上限")]),t._v("\n")])])]),a("p",[t._v("合理的根据自己的业务量进行调整")]),t._v(" "),a("h2",{attrs:{id:"http-缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http-缓存"}},[t._v("#")]),t._v(" Http 缓存")]),t._v(" "),a("p",[t._v("详见"),a("RouterLink",{attrs:{to:"/blog/http/HTTP缓存.html"}},[t._v("HTTP 缓存")]),t._v(",现在介绍下在 Nginx 中的配置")],1),t._v(" "),a("h2",{attrs:{id:"service-workers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#service-workers"}},[t._v("#")]),t._v(" Service Workers")]),t._v(" "),a("p",[t._v("在"),a("RouterLink",{attrs:{to:"/blog/webpack/webpack打包.html#pwa"}},[t._v("workbox-webpack-plugin")]),t._v("中我们介绍过,简单配置即可")],1),t._v(" "),a("blockquote",[a("p",[t._v("只能在本地和 https 下才能使用")])]),t._v(" "),a("h2",{attrs:{id:"http2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http2"}},[t._v("#")]),t._v(" Http2")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("二进制传输")])]),t._v(" "),a("li",[a("p",[t._v("请求相应多路复用")])]),t._v(" "),a("li",[a("p",[t._v("Server push")])])]),t._v(" "),a("p",[t._v("在 Nginx 开启 Htpps,配置证书,可以参考 "),a("a",{attrs:{href:"https://www.cnblogs.com/007sx/p/12583675.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("生成自签名的 SSL 证书和私钥"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("修改配置")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("server {\n\t# 添加 http2\n\tlisten 443 ssl http2;\n\t...\n}\n")])])]),a("h2",{attrs:{id:"ssr"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ssr"}},[t._v("#")]),t._v(" SSR")]),t._v(" "),a("p",[t._v("详见 "),a("RouterLink",{attrs:{to:"/blog/optimization/blog/node/SSR.html"}},[t._v("SSR")]),t._v(" 服务端渲染")],1),t._v(" "),a("h2",{attrs:{id:"加载顺序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#加载顺序"}},[t._v("#")]),t._v(" 加载顺序")]),t._v(" "),a("h3",{attrs:{id:"preload"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#preload"}},[t._v("#")]),t._v(" preload")]),t._v(" "),a("p",[a("strong",[t._v("Preload")]),t._v(" 来告诉浏览器预先请求当前页需要的资源，从而提高这些资源的请求优先级。比如,对于那些本来请求优先级较低的关键请求,我们可以通过设置 "),a("strong",[t._v("Preload")]),t._v(" 来提升这些请求的优先级。合理的安排优先级可以提升网站的性能,比如我们可以优先字体资源的下载")]),t._v(" "),a("h3",{attrs:{id:"prefetch"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#prefetch"}},[t._v("#")]),t._v(" prefetch")]),t._v(" "),a("p",[a("strong",[t._v("Prefetch")]),t._v(" 来告诉浏览器用户将来可能在其他页面(非本页面)可能使用到的资源,那么浏览器会在空闲时,就去预先加载这些资源放在 http 缓存,最常见的 "),a("strong",[t._v("dns-prefetch")]),t._v(".")]),t._v(" "),a("p",[t._v("从加载优先级上看,"),a("strong",[t._v("Preload")]),t._v(" 会提升请求优先级;而"),a("strong",[t._v("Prefetch")]),t._v("会把资源的优先级放在最低，当浏览器空闲时才去预加载。")]),t._v(" "),a("h3",{attrs:{id:"async"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#async"}},[t._v("#")]),t._v(" async")]),t._v(" "),a("p",[t._v("如果 script 脚本添加了此属性，浏览器会异步下载后立刻同步执行脚本。")]),t._v(" "),a("p",[t._v("说通俗点，脚本下载是异步行为，下载过程中并不影响 DOM 加载，但一旦脚本下载完毕就会立刻同步执行脚本，此时 DOM 加载还是得给我等着")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img2020.cnblogs.com/blog/1213309/202004/1213309-20200401172459415-1238649945.png",alt:"async"}})]),t._v(" "),a("h3",{attrs:{id:"defer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#defer"}},[t._v("#")]),t._v(" defer")]),t._v(" "),a("p",[t._v("与 async 一样属于异步下载脚本，但不同的地方是，脚本下载完成后并不会立刻执行，而是等到 DOM 解析完成才会执行脚本，相比 async 的粗暴，defer 明显更加实用。加载顺序如下图：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://img2020.cnblogs.com/blog/1213309/202004/1213309-20200401172519846-308126773.png",alt:"defer"}})])])}),[],!1,null,null,null);e.default=r.exports}}]);