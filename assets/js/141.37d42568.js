(window.webpackJsonp=window.webpackJsonp||[]).push([[141],{490:function(r,t,e){"use strict";e.r(t);var s=e(25),o=Object(s.a)({},(function(){var r=this,t=r.$createElement,e=r._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h1",{attrs:{id:"双缓存fiber树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#双缓存fiber树"}},[r._v("#")]),r._v(" 双缓存fiber树")]),r._v(" "),e("h2",{attrs:{id:"什么是双缓存？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是双缓存？"}},[r._v("#")]),r._v(" 什么是双缓存？")]),r._v(" "),e("p",[r._v("前面说了 React 最多会同时存在两棵 Fiber 树,那么什么是 "),e("font",{attrs:{color:"red"}},[r._v("双缓存")]),r._v("呢?")],1),r._v(" "),e("p",[r._v("当我们用 "),e("em",[r._v("canvas")]),r._v(" 绘制动画，每一帧绘制前都会调用 "),e("em",[r._v("ctx.clearRect")]),r._v(" 清除上一帧的画面。")]),r._v(" "),e("p",[r._v("如果当前帧画面计算量比较大，导致清除上一帧画面到绘制当前帧画面之间有较长间隙，就会出现白屏。")]),r._v(" "),e("p",[r._v("为了解决这个问题，我们可以在内存中绘制当前帧动画，绘制完毕后直接用当前帧替换上一帧画面，由于省去了两帧替换间的计算时间，不会出现从白屏到出现画面的闪烁情况。")]),r._v(" "),e("p",[r._v("这种 "),e("strong",[r._v("在内存中构建并直接替换")]),r._v(" 的技术叫做 "),e("font",{attrs:{color:"red"}},[r._v("双缓存")]),r._v("。")],1),r._v(" "),e("p",[e("strong",[r._v("React")]),r._v(" 使用“双缓存”来完成Fiber树的构建与替换——对应着 "),e("strong",[r._v("DOM树")]),r._v(" 的创建与更新。")]),r._v(" "),e("h2",{attrs:{id:"双缓存fiber树-2"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#双缓存fiber树-2"}},[r._v("#")]),r._v(" 双缓存Fiber树")]),r._v(" "),e("p",[r._v("在React中最多会同时存在两棵Fiber树。当前屏幕上显示内容对应的Fiber树称为current Fiber树，正在内存中构建的Fiber树称为workInProgress Fiber树。他们通过 "),e("strong",[r._v("alternate")]),r._v(" 属性连接")]),r._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[r._v("currentFiber"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(".")]),r._v("alternate "),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("===")]),r._v(" workInProgressFiber"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(";")]),r._v("\nworkInProgressFiber"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(".")]),r._v("alternate "),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("===")]),r._v(" currentFiber"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(";")]),r._v("\n")])])]),e("p",[r._v("React 应用的根节点通过 current 指针在不同的 Fiber树的 rootFiber 间切换来实现 Fiber树的切换")]),r._v(" "),e("p",[r._v("当workInProgress Fiber树构建完成交给Renderer渲染在页面上后，应用根节点的current指针指向workInProgress Fiber树，此时workInProgress Fiber树就变为current Fiber树。")]),r._v(" "),e("p",[r._v("每次状态更新都会产生新的workInProgress Fiber树，通过current与workInProgress的替换，完成DOM更新。")]),r._v(" "),e("p",[e("img",{attrs:{src:"/react/workInProgressFiber.png",alt:"workInProgressFiber"}})]),r._v(" "),e("h2",{attrs:{id:"mount"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mount"}},[r._v("#")]),r._v(" mount")]),r._v(" "),e("ol",[e("li",[r._v("首次执行ReactDOM.render会创建 fiberRootNode（源码中叫fiberRoot）和rootFiber。其中fiberRootNode是整个应用的根节点，rootFiber是"),e("App"),r._v("所在组件树的根节点。 会调用 "),e("strong",[r._v("createContainer")]),r._v(" 创建 "),e("strong",[r._v("FiberRoot")]),r._v(",并挂载在 root 的current 上")],1)]),r._v(" "),e("p",[r._v("之所以要区分fiberRootNode与rootFiber，是因为在应用中我们可以多次调用ReactDOM.render渲染不同的组件树，他们会拥有不同的rootFiber。但是整个应用的根节点只有一个，那就是fiberRootNode。")]),r._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[r._v("// 创建第一个FiberNode")]),r._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[r._v("const")]),r._v(" uninitializedFiber "),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("=")]),r._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[r._v("createHostRootFiber")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v("(")]),r._v("tag"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(";")]),r._v("\nroot"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(".")]),r._v("current "),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("=")]),r._v(" uninitializedFiber"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(";")]),r._v("\nuninitializedFiber"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(".")]),r._v("stateNode "),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("=")]),r._v(" root"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[r._v(";")]),r._v("\n")])])]),e("p",[r._v("由于是首屏渲染,页面中还没有挂载任何DOM，所以fiberRootNode.current指向的rootFiber没有任何子Fiber节点（即current Fiber树为空）。")]),r._v(" "),e("ol",{attrs:{start:"2"}},[e("li",[r._v("接下来进入render阶段,根据组件返回的JSX在内存中依次创建 "),e("strong",[r._v("Fiber")]),r._v(" 节点并连接在一起构建 "),e("strong",[r._v("Fiber")]),r._v(" 树，被称为 **workInProgress Fiber **树。（下图中右侧为内存中构建的树，左侧为页面显示的树）")])]),r._v(" "),e("p",[r._v("在构建workInProgress Fiber树时会尝试复用current Fiber树中已有的Fiber节点内的属性，在首屏渲染时只有rootFiber存在对应的current fiber（即rootFiber.alternate）。")]),r._v(" "),e("p",[e("img",{attrs:{src:"/react/rootFiber.jpeg",alt:"rootFiber"}})]),r._v(" "),e("ol",{attrs:{start:"3"}},[e("li",[r._v("右侧已构建完的workInProgress Fiber树在commit阶段渲染到页面。此时DOM更新为右侧树对应的样子。fiberRootNode的current指针指向workInProgress Fiber树使其变为current Fiber 树。\n"),e("img",{attrs:{src:"/react/currentFiber.jpeg",alt:"currentFiber"}})])]),r._v(" "),e("h2",{attrs:{id:"update"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#update"}},[r._v("#")]),r._v(" update")]),r._v(" "),e("p",[r._v("接下来我们点击p节点触发状态改变，这会开启一次新的render阶段并构建一棵新的 workInProgress Fiber 树。")]),r._v(" "),e("p",[e("img",{attrs:{src:"/react/workInProgressfiber1.png",alt:"workInProgressFiber"}})]),r._v(" "),e("p",[r._v("和mount时一样，"),e("strong",[r._v("workInProgress fiber")]),r._v(" 的创建可以复用 "),e("strong",[r._v("current Fiber")]),r._v(" 树对应的节点数据。")]),r._v(" "),e("blockquote",[e("p",[r._v("这个决定是否复用的过程就是Diff算法")])]),r._v(" "),e("p",[r._v("workInProgress Fiber 树在 "),e("strong",[r._v("render")]),r._v(" 阶段完成构建后进入 "),e("strong",[r._v("commit")]),r._v(" 阶段渲染到页面上。渲染完毕后，workInProgress Fiber 树变为 "),e("strong",[r._v("current Fiber")]),r._v(" 树 也就是第一张图那张。")])])}),[],!1,null,null,null);t.default=o.exports}}]);